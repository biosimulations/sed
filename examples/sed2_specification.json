{
    "Non-task elements": {
        "range": {
            "optionalInputs": {
                "start": "A double.  The first point of the range.",
                "end": "A double.  The final point of the range.",
                "numberOfSteps": "A positive integer.  The number of points after the first in the range.",
                "interval": "A double.  The size step to take after the start.",
                "scale": "Either 'linear' or 'log10'.  Assumed to be 'linear' if not included.  Only used if 'interval' is not defined.",
                "values": "A list of increasing-or-duplicate values.  I.e. [1, 2, 5, 10, 20] or [0, 1, 1, 2.3, 2.5].  If used, may not use any other optional input, as this completely defines the "
            },
            "Other vaidation rules": "If 'values' is not defined, exactly three of the optional inputs 'start', 'end', 'numberOfSteps', and 'interval' must be defined, which together define a series of values.",
            "notes": "Not a task itself, but used in tasks that need a range of values.  Not sure if 'scale' should be optional or required."
        }
    },
    "Task types": {
        "uniformTimeCourse": {
            "requiredInputs": {
                "model": "The input model or models to the simulator.  Must be an internal reference to an #input:models object, or to the output of another #task that can produce a model (or models).",
                "initialTime": "A double.  Required input to simulator, so it knows what the 'time' is for the input model as given.",
                "timeRange": "A 'range' object defining the time points at which to collect data.",
                "outputVariables": "A list of strings.  Defines what output to collect from the simulator.  As such, some simulators may use it as input (as is the case for tellurium)."
            },
            "optionalInputs": {
                "outputModel": "A boolean.  True if some other process needs the model-at-the-end-of-the-simulation as its own input.  False if the model does not need to be stored.  (Maybe make this requried?)"

            },
            "Other vaidation rules": "The parameters of the range will need to be provided to the simulator (i.e. 'r.simulate(0, 10, 100)' for roadrunner.",
            "outputs": {
                "values":  "A matrix of doubles.  The dimensions of the matrix are: models by outputVariables by range.  If only one model is used as input, the output is just a matrix of outputVariables by time points.  The outputVariables are the requried input, and the time points are determinable by the four inputs outputStartTime, outputEndTime, numberOfSteps, and timeInterval.  When used as input to other tasks or outputs, individual vectors of results for a single outputVariable may be obtained by asking for the id #tasks:timeCourseId[model#]['variableName'].  An example:  #tasks:sim1[0]['S1'].  If there is only one model input, the [model#] may be omitted, i.e. #tasks:sim1['S1'].",
                "model": "The model with its state as it is at the end of the simulation.  We know if we will need it if the 'outputModel' option is set.  Obtainable by asking for the id #tasks:timeCourseId:model, i.e. #tasks:sim1:model"
            },
            "notes": "Some systems do not have to simulate across time, but can use other variables, like space (CellML does this, and has been making due with SED-ML requiring time, but would probably like to not have to do this.  It might be time to explicitly define an independent variable for this construct, instead of assuming it's time."
        },
        "calculation": {
            "requiredInputs": {
                "math": "An infix math equation.  Could be as simple as '5'; could be more complicated like 'a*x^2+b*x+c'.  All non-numbers must be references to IDs elsewhere in the document, i.e. '#tasks:sim1['S1']'.  All functions performed on vectors or matrices or dictionaries are performed element-wise; there's not matrix algebra going on here (one could imagine a future 'matrixCalculation' task that allowed it).  '#tasks:sim1['time']*60' multiplies all elements of the 'time' vector by 60 (probably converting it from seconds to minutes).  '#tasks:sim1['S1'] / #tasks:sim1['C1']' divides all elements of the S1 vector by each corresponding element of the C1 vector, probably converting amounts to concentrations.  For all element-to-element functions like addition or multiplication, the elements must be the same size or a reduced dimension of the same size: the lengths of vectors must be the same; the labels of dictionaries must be the same; etc."
            },
            "optionalInputs": {
                "units": "The units of the output.  If a lower dimensionality than the output, it is assumed to apply to every element of the higher-dimensional output.  I.e. if the units are just 'mMol', and the output is a vector of doubles, we assume every element of the vector has units 'mMol'."
            },
            "Other validation rules": "The infix will be restricted, but we have not yet decided how restrictive to make it.  Basic math should be allowed (+, -, *, /, ^), and some functions (sum, avg, stdev).  Need to come up with full list as a community.  If a referenced input is a model, the model is taken as a dictionary of all model IDs to single values (the current state of the model).  The output will *not* be a model, just a dictionary of doubles.  To apply that dictionary to a model, use a modelChange.",
            "outputs": {
                "values": "The result of performing the math.  Could be multi-dimensional if the input was multi-dimensional."
            },
            "notes": "It might be nice to have an additional required input 'inputs' that simply listed all the references in the math equation:  if the 'math' was '#tasks:sim1['S1'] / #tasks:sim1['C1']', the 'inputs' would be ['#tasks:sim1['S1']', '#tasks:sim1['C1']'].  It's possible that we might want local variables as well, though that seems a bit much?  Something like ['#tasks:sim1['S1']', '#tasks:sim1['C1']', 'n=5']"
        },
        "sumOfSquares": {
            "requiredInputs": {
                "input1": "A SED ID.",
                "input2": "A SED ID with exactly the same dimensionality as input1."
            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": "Subtracts input1 from input2 element by element, squares the results, then sums them.  Returns a single double."
            },
            "notes": "This is an example of a sort of analysis that might be standardized.  It could also be accomplished with the 'calculation' task explicitly (in this case, 'sum((#input1 - #input2)^2)'), but doesn't require parsing infix."
        },
        "parameterScan": {
            "requiredInputs": {
                "model": "A SED ID reference to a model or vector/matrix of models.",
                "scannedVariable": "The ID of an element of the model(s).",
                "range": "A 'range' element defining the range of values to apply to the scannedVariable.",
                "outputRange": "A boolean indicating whether to output the 'range' object"
            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": "A vector or matrix of models, of the dimension [input models] x [range].  The first model will be the first input model with the 'scannedVariable' changed to the first value in the 'range', the second the next, etc.",
                "range": "A vector of the 'range' values.  Obtainable with the SED ID '#tasks:paramScanID:range', i.e. '#tasks:scan1:range'.  Available when 'outputRange' is set to 'true'."
            },
            "notes": "Maybe we should just assume 'outputRange' is always true and not let the user set it?"
        },
        "ex2": {
            "requiredInputs": {

            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": ""
            },
            "notes": ""
        },
        "ex3": {
            "requiredInputs": {

            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": ""
            },
            "notes": ""
        },
        "ex4": {
            "requiredInputs": {

            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": ""
            },
            "notes": ""
        },
        "ex5": {
            "requiredInputs": {

            },
            "optionalInputs": {

            },
            "Other validation rules": "",
            "outputs": {
                "values": ""
            },
            "notes": ""
        }
    }
}